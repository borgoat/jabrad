/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifndef __DBUS_GEN_H__
#define __DBUS_GEN_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for com.github.borgoat.Jabra1.Manager */

#define GBJ_TYPE_MANAGER (gbj_manager_get_type ())
#define GBJ_MANAGER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_MANAGER, gbjManager))
#define GBJ_IS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_MANAGER))
#define GBJ_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GBJ_TYPE_MANAGER, gbjManagerIface))

struct _gbjManager;
typedef struct _gbjManager gbjManager;
typedef struct _gbjManagerIface gbjManagerIface;

struct _gbjManagerIface
{
  GTypeInterface parent_iface;
};

GType gbj_manager_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *gbj_manager_interface_info (void);
guint gbj_manager_override_properties (GObjectClass *klass, guint property_id_begin);


/* ---- */

#define GBJ_TYPE_MANAGER_PROXY (gbj_manager_proxy_get_type ())
#define GBJ_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_MANAGER_PROXY, gbjManagerProxy))
#define GBJ_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GBJ_TYPE_MANAGER_PROXY, gbjManagerProxyClass))
#define GBJ_MANAGER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GBJ_TYPE_MANAGER_PROXY, gbjManagerProxyClass))
#define GBJ_IS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_MANAGER_PROXY))
#define GBJ_IS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GBJ_TYPE_MANAGER_PROXY))

typedef struct _gbjManagerProxy gbjManagerProxy;
typedef struct _gbjManagerProxyClass gbjManagerProxyClass;
typedef struct _gbjManagerProxyPrivate gbjManagerProxyPrivate;

struct _gbjManagerProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  gbjManagerProxyPrivate *priv;
};

struct _gbjManagerProxyClass
{
  GDBusProxyClass parent_class;
};

GType gbj_manager_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (gbjManagerProxy, g_object_unref)
#endif

void gbj_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
gbjManager *gbj_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
gbjManager *gbj_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void gbj_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
gbjManager *gbj_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
gbjManager *gbj_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define GBJ_TYPE_MANAGER_SKELETON (gbj_manager_skeleton_get_type ())
#define GBJ_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_MANAGER_SKELETON, gbjManagerSkeleton))
#define GBJ_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GBJ_TYPE_MANAGER_SKELETON, gbjManagerSkeletonClass))
#define GBJ_MANAGER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GBJ_TYPE_MANAGER_SKELETON, gbjManagerSkeletonClass))
#define GBJ_IS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_MANAGER_SKELETON))
#define GBJ_IS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GBJ_TYPE_MANAGER_SKELETON))

typedef struct _gbjManagerSkeleton gbjManagerSkeleton;
typedef struct _gbjManagerSkeletonClass gbjManagerSkeletonClass;
typedef struct _gbjManagerSkeletonPrivate gbjManagerSkeletonPrivate;

struct _gbjManagerSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  gbjManagerSkeletonPrivate *priv;
};

struct _gbjManagerSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType gbj_manager_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (gbjManagerSkeleton, g_object_unref)
#endif

gbjManager *gbj_manager_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for com.github.borgoat.Jabra1.Device */

#define GBJ_TYPE_DEVICE (gbj_device_get_type ())
#define GBJ_DEVICE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_DEVICE, gbjDevice))
#define GBJ_IS_DEVICE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_DEVICE))
#define GBJ_DEVICE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), GBJ_TYPE_DEVICE, gbjDeviceIface))

struct _gbjDevice;
typedef struct _gbjDevice gbjDevice;
typedef struct _gbjDeviceIface gbjDeviceIface;

struct _gbjDeviceIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_firmware_version) (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_get_search_device_list) (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_btpairing) (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_stop_btpairing) (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

  guint16  (*get_device_id) (gbjDevice *object);

  const gchar * (*get_device_name) (gbjDevice *object);

  gboolean  (*get_is_dongle) (gbjDevice *object);

  guint16  (*get_product_id) (gbjDevice *object);

  const gchar * (*get_usb_device_path) (gbjDevice *object);

  guint16  (*get_vendor_id) (gbjDevice *object);

  void (*button_in_data_translated) (
    gbjDevice *object,
    guint arg_translated_in_data,
    gboolean arg_button_in_data);

};

GType gbj_device_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *gbj_device_interface_info (void);
guint gbj_device_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void gbj_device_complete_get_firmware_version (
    gbjDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *firmware_version);

void gbj_device_complete_set_btpairing (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

void gbj_device_complete_stop_btpairing (
    gbjDevice *object,
    GDBusMethodInvocation *invocation);

void gbj_device_complete_get_search_device_list (
    gbjDevice *object,
    GDBusMethodInvocation *invocation,
    GVariant *devices);



/* D-Bus signal emissions functions: */
void gbj_device_emit_button_in_data_translated (
    gbjDevice *object,
    guint arg_translated_in_data,
    gboolean arg_button_in_data);



/* D-Bus method calls: */
void gbj_device_call_get_firmware_version (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean gbj_device_call_get_firmware_version_finish (
    gbjDevice *proxy,
    gchar **out_firmware_version,
    GAsyncResult *res,
    GError **error);

gboolean gbj_device_call_get_firmware_version_sync (
    gbjDevice *proxy,
    gchar **out_firmware_version,
    GCancellable *cancellable,
    GError **error);

void gbj_device_call_set_btpairing (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean gbj_device_call_set_btpairing_finish (
    gbjDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean gbj_device_call_set_btpairing_sync (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GError **error);

void gbj_device_call_stop_btpairing (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean gbj_device_call_stop_btpairing_finish (
    gbjDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean gbj_device_call_stop_btpairing_sync (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GError **error);

void gbj_device_call_get_search_device_list (
    gbjDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean gbj_device_call_get_search_device_list_finish (
    gbjDevice *proxy,
    GVariant **out_devices,
    GAsyncResult *res,
    GError **error);

gboolean gbj_device_call_get_search_device_list_sync (
    gbjDevice *proxy,
    GVariant **out_devices,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
guint16 gbj_device_get_device_id (gbjDevice *object);
void gbj_device_set_device_id (gbjDevice *object, guint16 value);

guint16 gbj_device_get_product_id (gbjDevice *object);
void gbj_device_set_product_id (gbjDevice *object, guint16 value);

guint16 gbj_device_get_vendor_id (gbjDevice *object);
void gbj_device_set_vendor_id (gbjDevice *object, guint16 value);

const gchar *gbj_device_get_device_name (gbjDevice *object);
gchar *gbj_device_dup_device_name (gbjDevice *object);
void gbj_device_set_device_name (gbjDevice *object, const gchar *value);

const gchar *gbj_device_get_usb_device_path (gbjDevice *object);
gchar *gbj_device_dup_usb_device_path (gbjDevice *object);
void gbj_device_set_usb_device_path (gbjDevice *object, const gchar *value);

gboolean gbj_device_get_is_dongle (gbjDevice *object);
void gbj_device_set_is_dongle (gbjDevice *object, gboolean value);


/* ---- */

#define GBJ_TYPE_DEVICE_PROXY (gbj_device_proxy_get_type ())
#define GBJ_DEVICE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_DEVICE_PROXY, gbjDeviceProxy))
#define GBJ_DEVICE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GBJ_TYPE_DEVICE_PROXY, gbjDeviceProxyClass))
#define GBJ_DEVICE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GBJ_TYPE_DEVICE_PROXY, gbjDeviceProxyClass))
#define GBJ_IS_DEVICE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_DEVICE_PROXY))
#define GBJ_IS_DEVICE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GBJ_TYPE_DEVICE_PROXY))

typedef struct _gbjDeviceProxy gbjDeviceProxy;
typedef struct _gbjDeviceProxyClass gbjDeviceProxyClass;
typedef struct _gbjDeviceProxyPrivate gbjDeviceProxyPrivate;

struct _gbjDeviceProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  gbjDeviceProxyPrivate *priv;
};

struct _gbjDeviceProxyClass
{
  GDBusProxyClass parent_class;
};

GType gbj_device_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (gbjDeviceProxy, g_object_unref)
#endif

void gbj_device_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
gbjDevice *gbj_device_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
gbjDevice *gbj_device_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void gbj_device_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
gbjDevice *gbj_device_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
gbjDevice *gbj_device_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define GBJ_TYPE_DEVICE_SKELETON (gbj_device_skeleton_get_type ())
#define GBJ_DEVICE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), GBJ_TYPE_DEVICE_SKELETON, gbjDeviceSkeleton))
#define GBJ_DEVICE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), GBJ_TYPE_DEVICE_SKELETON, gbjDeviceSkeletonClass))
#define GBJ_DEVICE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), GBJ_TYPE_DEVICE_SKELETON, gbjDeviceSkeletonClass))
#define GBJ_IS_DEVICE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), GBJ_TYPE_DEVICE_SKELETON))
#define GBJ_IS_DEVICE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GBJ_TYPE_DEVICE_SKELETON))

typedef struct _gbjDeviceSkeleton gbjDeviceSkeleton;
typedef struct _gbjDeviceSkeletonClass gbjDeviceSkeletonClass;
typedef struct _gbjDeviceSkeletonPrivate gbjDeviceSkeletonPrivate;

struct _gbjDeviceSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  gbjDeviceSkeletonPrivate *priv;
};

struct _gbjDeviceSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType gbj_device_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (gbjDeviceSkeleton, g_object_unref)
#endif

gbjDevice *gbj_device_skeleton_new (void);


G_END_DECLS

#endif /* __DBUS_GEN_H__ */
